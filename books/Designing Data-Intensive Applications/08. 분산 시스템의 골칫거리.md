# 분산 시스템의 골칫거리

> 어떤 것이든지 잘못될 가능성이 있다면 잘못된다.
> 

위 멘션은 시스템 운영자에게는 가장 합리적인 가정이다.

엔지니어는 모든 상황이 잘못되어 있더라도 제 역할을 해내는 시스템을 구축해야 한다.

## 결함과 부분 장애

- 일반적으로 컴퓨터 내부 결함이 발생하면 잘못된 결과를 반환하기보단 아예 동작하지 않기를 바란다.
    - 잘못된 결과는 다루기 어렵고 혼란스럽다.
- 한 컴퓨터에서 프로그램을 작성할 땐 보통 예측 가능한 방식으로 동작한다.
    - 되거나, 안 되거나 둘 중 하나
- 네트워크로 연결된 분산 시스템 환경에서는 예측 불가능한 오류가 발생한다.
    - 부분 장애(partial failure) 발생 시 원인이 비결정적이라서 고치기 어렵다.

### 클라우드 컴퓨팅과 슈퍼 컴퓨팅

- 대규모 컴퓨팅 시스템 구축 방법
    - 고성능 컴퓨팅: 기상 예보 등에 사용되는 슈퍼컴퓨터
    - 클라우드 컴퓨팅: 네트워크 상에서 연결된 컴퓨터
- 분산 시스템이 동작하게 만드려면 부분 장애 가능성를 고려하여 SW에 내결함성 메커니즘을 넣어야 한다.

## 신뢰성 없는 네트워크

- 내부 네트워크(이더넷)은 대부분 **비동기 패킷 네트워크**
    - 노드는 다른 노드로 메시지를 보낼 수 있으나 네트워크는 도착 여부를 보장하지 않는다.
- 잘못되는 케이스들
    1. 요청 손실
    2. 요청이 큐에서 장기간 대기 (네트워크 과부하 등 원인으로 인해)
    3. 원격 노드 장애 (전원이 꺼지는 물리적 장애 등)
    4. 원격 노드가 일시적으로 응답을 멈췄으나 나중에는 다시 응답 시작할 수 있음 (가비지 컬렉션 휴지가 길다던가)
    5. 원격 노드가 요청을 처리했지만 응답이 네트워크에서 손실 (네트워크 스위치 설정 오류 등)
    6. 원격 노드가 요청을 처리했으나 응답이 지연되다가 나중에 전송 (장비 과부하 등)

이런 문제는 보통 **타임 아웃** 으로 다룬다.

### 현실의 네트워크 결함

- 단일 장비 연결이 끊어지거나, 전체 랙 연결이 끊어지는 경우
- top-of-rack switch, aggregation switch, 로드 밸런서 같은 구성 요소 장애
- 인적 오류 (스위치 설정 오류 등)
- 반드시 네트워크 결함을 견뎌내도록 처리할 필요는 없이 네트워크 오류 시 적당한 오류메시지를 보여주는 것도 타당한 방법
- SW가 문제로부터 복구할 필요는 있다.

### 결함 감지

- 결함있는 노드는 자동으로 감지되어야 한다.
    - 로드 밸런서는 죽은 노드로 요청을 보내면 안된다.
    - 단일 리더 복제를 사용하는 분산 데이터베이스에서 리더에 장애가 발생하면 팔로워 중 하나가 리더로 승격되어야 한다.
- 네트워크에 관한 불확실성으로 노드가 동작 중인지 구별하기 어렵다면 명시적인 피드백을 받는다.
- 요청이 성공했음을 확신하고 싶다면 애플리케이션 자체로부터 긍정 응답을 받아야 한다.
- 요청이 잘못되면 아무 응답도 받지 못할거라고 가정을 하는게 좋다.

### 타임아웃과 기약 없는 지연

- 타임아웃이 길면 기다리는 시간이 길고, 짧으면 노드가 죽었다고 잘못 판단할 가능성이 높아진다.
- 노드가 죽었다고 선언되면 다른 노드에게 부하를 전가해야 한다.
    - 이미 높은 부하에 시달리는 중이면 성급하게 노드가 죽었음을 선언하는건 독이 될 수 있다.
    - 노드가 죽은게 아니라 과부하 때문에 응답이 느린 것일수도 있다.

### 네트워크 혼잡과 큐 대기

- 네트워크에서 패킷 지연의 변동성은 큐 대기 때문인 경우가 많다.
- 여러 개의 다른 노드가 동시에 같은 목적지로 패킷을 보내려고 하면 네트워크 스위치는 패킷을 큐에 넣고 하나씩 전송한다. 데이터 양이 많아 큐를 꽉 채울 정도가 되면 패킷이 유실되어 재전송해야 할 수 도 있다.
- 패킷이 목적지에 도착했을 때 모든 CPU 코어가 바쁜 상태라면 네트워크에서 들어온 요청이 처리될 준비가 될 때까지 운영체제가 큐에 넣어둔다.
- 가상 환경 상의 OS는 다른 가상 장비가 CPU 코어를 사용하는 동안 잠깐 멈추는 경우가 많다. 이 순간 가상 장비는 어떤 데이터도 받을 수 없어 가상 장비 모니터가 들어오는 데이터를 큐에 넣어 버퍼링하고, 네트워크 지연의 변동성을 증가시킨다.
- TCP를 사용하면 타임아웃 안에 확인 응답을 받지 않으면 패킷을 손실됐다고 간주하고 재전송한다.
- 고정된 타임아웃을 설정하는 대신 시스템이 지속적으로 응답 시간과 변동성(지터, jitter) 을 측정하여 관찰된 응답 시간 분포도에 따라 유동적인 타임아웃을 설정하는 방법도 있다.
    - 파이 증가 장애 감지기(Phi Accrual failure detector) 를 사용한다.
    - 아카(Akka)와 카산드라가 이를 사용하는 예시이다.

### 동기 네트워크 vs 비동기 네트워크

- 전화 네트워크는 극단적인 신뢰성을 지닌 동기식 네트워크의 예시이다.
    - 음성 프레임이 지연되거나 통화가 유실되면 안되기 때문
    - 전화는 end-to-end 지연 시간이 낮아야 하며 목소리를 전달할 대역폭이 충분해야 한다.
    - 통화를 할 때 **회선(circuit)** 이 생성되며 통화를 하는 두 사람 사이 고정된 양의 대역폭이 할당된다.
    - 데이터가 여러 라우터를 거치더라도 큐 대기 시간을 겪지 않는다. 통화당 대역폭이 이미 할당되었기 때문이다.
    - 큐 대기가 없으므로 네트워크 종단 지연 시간 최대치가 고정되어 있다. (제한 있는 지연, bounded delay)

## 신뢰성 없는 시계

- 어플리케이션에 시계에 의존하는 예시
    1. 이 요청이 타임아웃 되었는가?
    2. 이 서비스의 99분위 응답 시간은 어떻게 되나?
    3. 이 서비스는 지난 5분 동안 평균 초당 몇 개의 질의를 처리했나?
    4. 사용자가 우리 사이트에서 시간을 얼마나 보냈나?
    5. 이 기사가 언제 게시됐나?
    6. 며칠 몇 시에 미리 알림 이메일을 보내야 하나?
    7. 이 캐시 항목은 언제 만료되나?
    8. 로그 파일에 남은 이 오류 메시지의 타임스탬프는 무엇인가?

1, 4번은 지속 시간을, 5, 8은 시점을 기술한다.

보통 NTP(Network Time Protocol)을 사용하여 서버 그룹 내에서 같은 시간을 사용한다.

### 단조 시계와 일 기준 시계

- 일 기준 시계(time-of-day clock)
    - 일반적으로 사용하는 시계를 의미
    - 보통 NTP로 동기화
    - 로컬 시계가 NTP 보다 앞서는 경우 강제로 리셋되어 과거 시점으로 거꾸로 뛰는 것처럼 보이기도 한다.
- 단조 시계(monotonic clock)
    - 시작 시간부터 재는 시간
    - 타임아웃이나 서비스 응답/지속 시간을 재는데 적합
    - `System.nanoTime()` 등이 있다.

### 시계 동기화와 정확도

- 일 기준 시계는 동기화가 필요하고 단조 시계는 동기화가 필요 없다.
- 시계가 정확한 시간을 알려주게 하는 방법은 생각보다 신뢰성이 적고 정확하지 않다.
    - 장비 온도에 따라 시간이 더 빠르거나 느리게 실행된다.
    - 로컬 시계와 NTP 시간 차이가 너무 크면 갑자기 동기화되며 시계가 꼬인다. 시간이 거꾸로 돌아가거나 뛰는 현상이 발생한다.
    - 윤초가 발생하면 1분의 길이가 59 ~ 61초가 되어 윤초를 고려하지 않은 시스템에서 장애가 날 가능성이 생긴다.

### 동기화된 시계에 의존하기

- 네트워크가 대부분의 시간에 잘 동작하더라도 소프트웨어는 네트워크에 가끔 결함이 생길 수 있다는 가정하에 설계되어야 한다.
    - 소프트웨어는 그 결함을 우아하게 처리해야 한다.
- 대부분의 시간에 아주 잘 동작하나 견고한 소프트웨어는 잘못된 시계에 대비할 필요가 있다.
- 시간 오류는 파악하기 어렵고 잘 동작하는 것처럼 착각하기 쉽다.
- 동기화된 시계가 필요한 소프트웨어를 사용한다면 **모든 장비의 시간을 모니터링**해야 한다.
- 다른 노드와 시간 차이가 너무 크면 죽은 것으로 판단하고 클러스터에서 제거한다.
- 이렇게 하면 큰 피해를 입기 전 고장난 시계를 감지할 수 있다.
