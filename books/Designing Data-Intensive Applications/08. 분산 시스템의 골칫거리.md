# 분산 시스템의 골칫거리

> 어떤 것이든지 잘못될 가능성이 있다면 잘못된다.

위 멘션은 시스템 운영자에게는 가장 합리적인 가정이다.

엔지니어는 모든 상황이 잘못되어 있더라도 제 역할을 해내는 시스템을 구축해야 한다.

## 결함과 부분 장애

- 일반적으로 컴퓨터 내부 결함이 발생하면 잘못된 결과를 반환하기보단 아예 동작하지 않기를 바란다.
    - 잘못된 결과는 다루기 어렵고 혼란스럽다.
- 한 컴퓨터에서 프로그램을 작성할 땐 보통 예측 가능한 방식으로 동작한다.
    - 되거나, 안 되거나 둘 중 하나
- 네트워크로 연결된 분산 시스템 환경에서는 예측 불가능한 오류가 발생한다.
    - 부분 장애(partial failure) 발생 시 원인이 비결정적이라서 고치기 어렵다.

### 클라우드 컴퓨팅과 슈퍼 컴퓨팅

- 대규모 컴퓨팅 시스템 구축 방법
    - 고성능 컴퓨팅: 기상 예보 등에 사용되는 슈퍼컴퓨터
    - 클라우드 컴퓨팅: 네트워크 상에서 연결된 컴퓨터
- 분산 시스템이 동작하게 만드려면 부분 장애 가능성를 고려하여 SW에 내결함성 메커니즘을 넣어야 한다.

## 신뢰성 없는 네트워크

- 내부 네트워크(이더넷)은 대부분 **비동기 패킷 네트워크**
    - 노드는 다른 노드로 메시지를 보낼 수 있으나 네트워크는 도착 여부를 보장하지 않는다.
- 잘못되는 케이스들
    1. 요청 손실
    2. 요청이 큐에서 장기간 대기 (네트워크 과부하 등 원인으로 인해)
    3. 원격 노드 장애 (전원이 꺼지는 물리적 장애 등)
    4. 원격 노드가 일시적으로 응답을 멈췄으나 나중에는 다시 응답 시작할 수 있음 (가비지 컬렉션 휴지가 길다던가)
    5. 원격 노드가 요청을 처리했지만 응답이 네트워크에서 손실 (네트워크 스위치 설정 오류 등)
    6. 원격 노드가 요청을 처리했으나 응답이 지연되다가 나중에 전송 (장비 과부하 등)

이런 문제는 보통 **타임 아웃** 으로 다룬다.

### 현실의 네트워크 결함

- 단일 장비 연결이 끊어지거나, 전체 랙 연결이 끊어지는 경우
- top-of-rack switch, aggregation switch, 로드 밸런서 같은 구성 요소 장애
- 인적 오류 (스위치 설정 오류 등)
- 반드시 네트워크 결함을 견뎌내도록 처리할 필요는 없이 네트워크 오류 시 적당한 오류메시지를 보여주는 것도 타당한 방법
- SW가 문제로부터 복구할 필요는 있다.

### 결함 감지

- 결함있는 노드는 자동으로 감지되어야 한다.
    - 로드 밸런서는 죽은 노드로 요청을 보내면 안된다.
    - 단일 리더 복제를 사용하는 분산 데이터베이스에서 리더에 장애가 발생하면 팔로워 중 하나가 리더로 승격되어야 한다.
- 네트워크에 관한 불확실성으로 노드가 동작 중인지 구별하기 어렵다면 명시적인 피드백을 받는다.
- 요청이 성공했음을 확신하고 싶다면 애플리케이션 자체로부터 긍정 응답을 받아야 한다.
- 요청이 잘못되면 아무 응답도 받지 못할거라고 가정을 하는게 좋다.

### 타임아웃과 기약 없는 지연

- 타임아웃이 길면 기다리는 시간이 길고, 짧으면 노드가 죽었다고 잘못 판단할 가능성이 높아진다.
- 노드가 죽었다고 선언되면 다른 노드에게 부하를 전가해야 한다.
    - 이미 높은 부하에 시달리는 중이면 성급하게 노드가 죽었음을 선언하는건 독이 될 수 있다.
    - 노드가 죽은게 아니라 과부하 때문에 응답이 느린 것일수도 있다.

### 네트워크 혼잡과 큐 대기

- 네트워크에서 패킷 지연의 변동성은 큐 대기 때문인 경우가 많다.
- 여러 개의 다른 노드가 동시에 같은 목적지로 패킷을 보내려고 하면 네트워크 스위치는 패킷을 큐에 넣고 하나씩 전송한다. 데이터 양이 많아 큐를 꽉 채울 정도가 되면 패킷이 유실되어 재전송해야 할 수 도 있다.
- 패킷이 목적지에 도착했을 때 모든 CPU 코어가 바쁜 상태라면 네트워크에서 들어온 요청이 처리될 준비가 될 때까지 운영체제가 큐에 넣어둔다.
- 가상 환경 상의 OS는 다른 가상 장비가 CPU 코어를 사용하는 동안 잠깐 멈추는 경우가 많다. 이 순간 가상 장비는 어떤 데이터도 받을 수 없어 가상 장비 모니터가 들어오는 데이터를 큐에 넣어 버퍼링하고, 네트워크 지연의 변동성을 증가시킨다.
- TCP를 사용하면 타임아웃 안에 확인 응답을 받지 않으면 패킷을 손실됐다고 간주하고 재전송한다.
- 고정된 타임아웃을 설정하는 대신 시스템이 지속적으로 응답 시간과 변동성(지터, jitter) 을 측정하여 관찰된 응답 시간 분포도에 따라 유동적인 타임아웃을 설정하는 방법도 있다.
    - 파이 증가 장애 감지기(Phi Accrual failure detector) 를 사용한다.
    - 아카(Akka)와 카산드라가 이를 사용하는 예시이다.

### 동기 네트워크 vs 비동기 네트워크

- 전화 네트워크는 극단적인 신뢰성을 지닌 동기식 네트워크의 예시이다.
    - 음성 프레임이 지연되거나 통화가 유실되면 안되기 때문
    - 전화는 end-to-end 지연 시간이 낮아야 하며 목소리를 전달할 대역폭이 충분해야 한다.
    - 통화를 할 때 **회선(circuit)** 이 생성되며 통화를 하는 두 사람 사이 고정된 양의 대역폭이 할당된다.
    - 데이터가 여러 라우터를 거치더라도 큐 대기 시간을 겪지 않는다. 통화당 대역폭이 이미 할당되었기 때문이다.
    - 큐 대기가 없으므로 네트워크 종단 지연 시간 최대치가 고정되어 있다. (제한 있는 지연, bounded delay)

## 신뢰성 없는 시계

- 어플리케이션에 시계에 의존하는 예시
    1. 이 요청이 타임아웃 되었는가?
    2. 이 서비스의 99분위 응답 시간은 어떻게 되나?
    3. 이 서비스는 지난 5분 동안 평균 초당 몇 개의 질의를 처리했나?
    4. 사용자가 우리 사이트에서 시간을 얼마나 보냈나?
    5. 이 기사가 언제 게시됐나?
    6. 며칠 몇 시에 미리 알림 이메일을 보내야 하나?
    7. 이 캐시 항목은 언제 만료되나?
    8. 로그 파일에 남은 이 오류 메시지의 타임스탬프는 무엇인가?

1, 4번은 지속 시간을, 5, 8은 시점을 기술한다.

보통 NTP(Network Time Protocol)을 사용하여 서버 그룹 내에서 같은 시간을 사용한다.

### 단조 시계와 일 기준 시계

- 일 기준 시계(time-of-day clock)
    - 일반적으로 사용하는 시계를 의미
    - 보통 NTP로 동기화
    - 로컬 시계가 NTP 보다 앞서는 경우 강제로 리셋되어 과거 시점으로 거꾸로 뛰는 것처럼 보이기도 한다.
- 단조 시계(monotonic clock)
    - 시작 시간부터 재는 시간
    - 타임아웃이나 서비스 응답/지속 시간을 재는데 적합
    - `System.nanoTime()` 등이 있다.

### 시계 동기화와 정확도

- 일 기준 시계는 동기화가 필요하고 단조 시계는 동기화가 필요 없다.
- 시계가 정확한 시간을 알려주게 하는 방법은 생각보다 신뢰성이 적고 정확하지 않다.
    - 장비 온도에 따라 시간이 더 빠르거나 느리게 실행된다.
    - 로컬 시계와 NTP 시간 차이가 너무 크면 갑자기 동기화되며 시계가 꼬인다. 시간이 거꾸로 돌아가거나 뛰는 현상이 발생한다.
    - 윤초가 발생하면 1분의 길이가 59 ~ 61초가 되어 윤초를 고려하지 않은 시스템에서 장애가 날 가능성이 생긴다.

### 동기화된 시계에 의존하기

- 네트워크가 대부분의 시간에 잘 동작하더라도 소프트웨어는 네트워크에 가끔 결함이 생길 수 있다는 가정하에 설계되어야 한다.
    - 소프트웨어는 그 결함을 우아하게 처리해야 한다.
- 대부분의 시간에 아주 잘 동작하나 견고한 소프트웨어는 잘못된 시계에 대비할 필요가 있다.
- 시간 오류는 파악하기 어렵고 잘 동작하는 것처럼 착각하기 쉽다.
- 동기화된 시계가 필요한 소프트웨어를 사용한다면 **모든 장비의 시간을 모니터링**해야 한다.
- 다른 노드와 시간 차이가 너무 크면 죽은 것으로 판단하고 클러스터에서 제거한다.
- 이렇게 하면 큰 피해를 입기 전 고장난 시계를 감지할 수 있다.

### 이벤트 순서화용 타임스탬프

- 아래의 케이스를 생각해보자.
    
    ```
    아래 일은 번호 순서대로 일어난 일이며, 각 번호가 커밋된 후 다음 번호를 수행한다고 가정한다.
    노드는 총 3개가 존재하며 각 노드는 시간이 동기화되어 있지 않다.
    
    1. 유저 A가 x의 값을 1로 설정한 시간이 42.05초 (노드 1)
    2. 유저 B가 x의 값을 2로 설정한 시간이 42.03초 (노드 3)
    
    실제로는 A가 먼저 값을 설정하고 그 후 B가 값을 설정했지만,
    timestamp 기준으로 최신 데이터를 판단하고 있다면 B의 작업은 버려진다.
    ```
    
- 잘못된 순서를 바로 잡을 정도로 정확한 NTP 동기화는 불가능하다.
- logical clock은 좋은 대안이 될 수 있다.
    - 정확한 시간 대신 증가하는 카운터를 기반으로 한다.

### 시계 읽기의 신뢰 구간

- 일 기준 시계를 아무리 세밀하게 측정한들 정확하다는 보장은 없다.
- NTP 서버와 매 분 동기화하더라도 부정확한 시계에서 발생하는 차이는 발생할 수 있다.
- 따라서 시간은 정확하게 읽기보다는 신뢰 구간에 속한다고 보는게 더 타당하다.
    - 구글의 **TrueTime API**는 신뢰구간 내 가장 이른 시간, 가장 늦은 시간을 함께 반환한다.

### 전역 스냅샷용 동기화된 시계

- 가장 흔한 스냅샷 격리 구현은 단조 증가하는 트랜잭션 ID 필요
    - 단일 노드 DB에선 단순 카운터로 충분
- 다중 노드 DB에선 단조 증가 트랜잭션 ID 생성이 어렵다.
    - 시계를 ID로 사용한다면 시계 정확도에 대한 확실성이 있어야 한다.
    - 신뢰 구간 기반으로 구현하는 방법이 있다. 시계 신뢰 구간 두 개가 서로 겹치지 않으면 트랜잭션의 순서를 확신할 수 있다.
        - 하나는 1.01초 ~ 1.03초, 다른 하나는1.04초 ~ 1.05초라면 겹치지 않는다.
        - 각 노드의 시간을 지속적으로 동기화해주어야 한다. 구글은 7ms 이하를 유지한다.

### 프로세스 중단

- 파티션마다 리더가 하나씩 있는 DB에서 리더만 쓰기가 가능한 경우, 그 노드가 여전히 리더인지, 안전하게 쓰기 작업을 수행할 수 있는지를 어떻게 알 수 있을까?
    - 리더가 다른 노드들로부터 임차권(lease)를 얻으면 된다.
    - 특정 시점엔 하나의 리더만 임차권을 얻는다.
    - 노드가 리더 역할을 계속 수행하려면 임차권을 주기적으로 갱신해야 한다.
    - 노드에 장애가 발생하면 임차권이 갱신되지 않아 다른 노드가 리더를 넘겨받는다.

### 응답 시간 보장

- 스레드와 프로세스는 기약 없는 시간동안 중단될 수 있다.
- 항공기, 로켓, 로봇, 자동차 등 제어에 사용되는 컴퓨터는 센서 입력에 빠르게 응답해야 한다.
    - 이런 시스템에선 보통 SW 응답시간을 **데드라인(deadline)**으로 정해둔다.
    - 데드라인을 만족시키지 못하면 시스템 장애가 일어날 수 있다.
    - 엄격한 실시간 시스템(hard real-time)이라고 한다.
- 프로세스가 명시된 간격의 CPU 시간을 할당받도록 보장하는 스케줄링을 탑재한 실시간 운영체제(real-time operation system, RTOS)가 필요하다.
- 실시간 ≠ 고성능
    - 성능보단 제 때에 응답하는 것이 더 중요

### 가비지 컬렉션의 영향 제한

- GC가 발생하면 시스템이 일시적으로 중단될 수 있다.
- GC 중단을 노드가 잠시 계획적으로 중단되는 것으로 간주하고 노드가 GC를 수행하는 동안 클라이언트의 요청을 다른 노드가 처리하도록 유도한다.

## 지식, 진실, 거짓말

- 네트워크의 모든 노드에는 **확실함** 이란 것이 없다.
- 시스템의 어떤 것이 진실이고 무엇이 거짓인가?
- 일정 수준까지 보장하는 것으로 신뢰성 있는 동작을 달성할 수 있다.

### 진실은 다수결로 결정

- 비대칭 결함이 있는 네트워크에서, 한 노드가 메시지를 잘 받을 수 있지만 전송하는 경우 유실이나 지연이 발생하는 경우
    - 이 노드는 잘 작동되고 있으나 다른 노드가 요청을 한 경우 타임아웃이 발생한다.
    - 타임아웃으로 인해 다른 노드는 이 노드가 죽었다고 판단한다.
- stop-the-world 로 인해 중단을 경험하는 노드
    - 모든 스레드는 GC에 선점되고 일정 시간 동안 중지
    - 다른 노드는 몇 번이나 재시도하지만 모드 실패하고 노드가 죽은 것으로 판단
    - 그 이후 GC가 종료되어 작업을 순차적으로 처리하기 시작
- 위 예시들은 노드 상황에 대한 판단이 반드시 확실한 것을 아님을 보여준다.

### 리더와 잠금

- 단일의 "무언가"가 필요한 예시
    - 스플릿 브레인을 피하기 위해 한 노드만 DB 파티션의 리더가 되는 경우
    - 특정 자원이나 객체에 동시에 쓰거나 오염시키는 것을 방지하기 위해 한 트랜잭션이나 클라이언트만 잠금을 획득하는 경우
    - 사용자명으로 사용자를 유일하게 식별해야 하므로 사용자명을 고유하게 유지하는 경우
- 한 노드가 리더, 혹은 잠금 획득, 특정한 사용자명을 차지했다고 믿고 있더라도 노드의 정족수도 반드시 동의하고 있지는 않다.
    - 리더인 노드는 네트워크 중단, GC 등으로 인해 죽었다고 판단되어 다른 리더가 선출될 수 있다.
    - 과반수의 노드가 특정 노드를 죽었다고 판단했으나 그 노드가 여전히 선택된 자인 것처럼 행동하면 시스템에서 오류가 발생할 수 있다.
