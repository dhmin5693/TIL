# 트랜잭션

> 어떤 저자들은 2단계 커밋에서 유발되는 성능이나 가용성 문제 때문에 생기는 비용이 너무 커서 이를 지원할 수 없다고 주장했다. 우리는 항상 트랜잭션 없이 코딩하는 것보다 트랜잭션을 과용해서 병목지점이 생기는 성능 문제를 애플리케이션 프로그래머가 처리하게 하는게 낫다고 생각한다.

## 개요

### 데이터 시스템이 유발할 수 있는 문제들

- DB 노드의 HW/SW는 언제든지 중지될 수 있으며 실패할 수 있다.
- 애플리케이션 또한 마찬가지로 언제든지 죽을 수 있다.
- 네트워크가 갑자기 중단되면 DB 연결이 갑자기 끊기거나 DB 노드 사이 통신이 안될 수 있다.
- 여러 클라이언트가 동시에 DB write를 수행하여 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다.
- 클라이언트가 부분적으로만 갱신되어서 비정상적인 데이터를 읽을 수 있다.
- 클라이언트 사이의 경쟁 조건은 예측하지 못한 버그를 유발할 수 있다.

### 트랜잭션의 정의

- 여러 개의 읽기/쓰기 작업을 하나의 논리적 단위로 묶은 것
- 전체가 성공하거나, 모두 실패하거나
    - 안정성 보장
- read committed, snapshot isolation, serializability 격리 수준 지원

## 트랜잭션의 애매모호함

### ACID

- DB마다 ACID 구현이 제각각
- ACID를 따르지 않는 시스템은 BASE를 지원한다고들 한다.
    - **B**asically **A**vailable
    - **S**oft state
    - **E**ventual Consistency

### 원자성

- 연산은 실행 전/후의 상태만 있을 뿐, 중간 상태엔 머무를 수 없다.
- 원자성은 동시성과 관련이 없다.
- 원자성은 여러 프로세스가 동시에 같은 데이터에 접근하려 할 때 무슨 일이 생기는지 설명하지 않는다.
- 원자성의 결정적인 특징은 오류 발생 시 모든 연산을 rollback하는 것이다.

### 일관성

- 복제 일관성과 비동기식 복제되는 시스템에서 발생하는 최종적 일관성 (5장)
- 일관성 해싱은 재균형화를 위해 사용하는 파티셔닝 기법
- 일관성은 선형성을 의미
- 일관성은 데이터베이스가 "좋은 상태"에 있어야 한다는 것의 애플리케이션에 특화된 개념
    - 원자성, 격리성, 지속성은 데이터베이스의 속성
    - 일관성은 데이터베이스 뿐만 아니라 애플리케이션에서도 지켜주어야 한다.
    - 따라서 C는 ACID에 실제로 속하는 것이 아니다.

### 격리성

- 클라이언트가 DB의 같은 레코드에 접근하면 동시성 문제가 발생
- 동시에 실행되는 트랜잭션은 서로 격리된 상태
- 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션이 커밋됐을 떄의 결과는 트랜잭션이 순차적으로 실행됐을 떄와 동일함을 보장
- serializable isolation은 성능 손해가 막심하여 실제로는 거의 사용되지 않음.

### 지속성

- 기본적으로 HDD나 SSD 등 비휘발성 저장소에 기록
- 저장소에 저장된 데이터의 오염을 방지하여 `write-ahead log` 와 같은 수단 동반
- 복제 기능을 갖춘 DB는 모든 노드에 복사가 완료되어야 지속성을 만족
- 지속성을 보장하려면 DB는 트랜잭션 성공 전에 복제가 완료될 때까지 기다려야 한다.

### 단일 객체 연산과 다중 객체 연산

- ACID에서 원자성과 격리성은 클라이언트가 한 트랜잭션 내에서 여러 번의 쓰기를 하면 어떻게 될까?
    - 원자성은 all or nothing을 보장하여 부분 실패를 걱정하지 않게끔 한다.
    - 격리성은 트랜잭션이 서로를 방해하지 않도록 보장한다.

### 단일 객체 쓰기

- 원자성과 격리성은 단일 객체를 변경하는 경우에도 적용된다.
- 원자성은 장애 복구(crash recovery)용 로그를 사용하여 구현 가능
- 격리성은 객체 잠금(lock)을 활용하여 구현 가능

### 다중 객체 트랜잭션의 필요성

- 많은 분산형 데이터베이스에서 지원하지 않음

### 오류와 어보트 처리

- 오류 발생 시 어보트 및 안전한 재시도는 트랜잭션의 핵심 기능
    - ACID의 철학이기도 하다.
- 리더 없는 복제 기법을 사용하는 DB는 "best effort"를 기반으로 훨씬 더 많은 일을 하는 대신 이 철학을 따르진 않는다.
    - 오류 복구는 애플리케이션에게 맡긴다.
    - Rails, Django와 같은 특정 프레임워크는 어보트된 트랜잭션을 재시도하지 않으므로 주의가 필요하다.
- 어보트된 트랜잭션 재시도는 효과적이지만 완벽하지 않을 수 있다.
    - 트랜잭션은 성공했으나 네트워크 오류로 서버가 클라이언트에게 커밋 성공을 알리지 못하여 재시도
    - 오류의 원인이 과도한 트래픽이라면 트랜잭션 재시도는 문제를 더욱 악화시키는 행위
    - 회복 가능한 일시적인 오류가 아니라 영구적 오류인 경우 재시도하여도 같은 현상을 반복
    - 트랜잭션이 DB 외부에도 부수 효과가 있다면 트랜잭션이 어보트될 때에도 부수 효과가 실행됨
    - 클라이언트 프로세스가 재시도 중에 죽으면 클라이언트에서 DB에 쓰려고 했던 데이터가 모두 손실

### 완화된 격리 수준

- 두 트랜잭션이 동일한 데이터에 접근하지 않는다면 안전하게 병렬 처리가 가능하다.
- 동시성 문제는 서로 다른 트랜잭션에서 동시에 같은 데이터를 변경하거나 읽으려고 하는 경우에 발생한다.
    - 타이밍에 의해 발생되어 테스트로 발견하기도 어렵고 재현하기도 어렵다.
- **트랜잭션 격리**를 통해 동시성 문제를 완화할 수 있지만 성능 문제가 있을 수 있다.

### 커밋 후 읽기 (Read Committed)

- 가장 기본적인 **트랜잭션 격리 수준**
- 커밋된 데이터만 읽을 수 있음.
- 커밋된 데이터만 덮어 쓸 수 있음.
- dirty read 방지
    - commit되지 않은 데이터를 읽는 현상
    - dirty read가 발생하면 다른 트랜잭션에서 갱신된 값과 갱신되지 않은 값을 혼용하여 읽을 수도 있다.
- dirty write 방지
    - 두 트랜잭션이 동일한 객체를 동시에 갱신하려고 할 때, 먼저 쓴 내용이 아직 커밋되지 않은 트랜잭션에서 쓴 것이고 나중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어써버리는 현상
- 로우 잠금 수준을 사용하여 dirty write를 방지
    - 특정 row를 변경하려면 해당 row에 대한 lock을 획득해야 한다.
    - 트랜잭션이 끝날 때까지 lock을 보유한다.
    - 특정 row에 대한 lock은 한 트랜잭션만 가질 수 있다.
- dirty read는 동일한 lock을 사용하여 읽기를 원하는 트랜잭션이 lock을 잠깐 획득하고 종료와 동시에 해제한다.
    - read lock은 한 row를 오래 잠궈두면 속도 문제가 발생할 수 있어 잘 사용되지 않는다.

### snapshot 격리와 반복 읽기 (Repeatable Read)

- 일시적인 데이터 불일치 현상 방지
- 스냅샷 격리를 통해 커밋된 상태였던 데이터를 본다.
- 읽기만 실행하는 질의에 요긴하다.
- 스냅샷 격리는 읽는 쪽에서 쓰는 쪽을 차단하지 않고 쓰는 쪽에서 읽는 쪽을 차단하지 않는다.
    - lock 경쟁 없이 처리할 수 있어 오래 실행되는 읽기 작업도 처리할 수 있다.
- 여러 트랜잭션이 서로 다른 시점의 DB 상태를 보는 경우, DB는 여러 버전을 함께 유지하고 있어야 한다.
    - 이 기법은 다중 버전 동시성 제어(multi-version concurrency control, MVCC)라 한다.

### 갱신 손실 방지

- 두 트랜잭션이 동시에 쓰기를 실행한 경우 쓰기 충돌(write-write conflict)이 일어날 수 있다.
    - lost update같은 문제도 있다. 특정 트랜잭션의 작업이 무시된다.
- 원자적 쓰기 연산을 통한 방지
    - 데이터의 일부만 갱신
    - 해당 객체에 exclusive lock을 획득하여 구현
- compare-and-set 연산으로 갱신 손실 회피 가능

### 충돌 해소와 복제

- 복제를 적용한 DB에서 갱신 손실을 방지하는 것은 어려운 문제
- 여러 노드에 데이터가 동시에 존재하기 때문에 lock, compare-and-set 기법을 적용할 수 없다.
- 여러 개의 충돌되는 버전을 생성한 후 사후에 애플리케이션 혹은 특별한 데이터 구조를 사용하여 충돌 해소 및 버전 병합
- last write wins(LWW) 는 충돌을 해소하기 가장 쉬운 방법이지만 갱신 손실이 발생하기 쉽다.
