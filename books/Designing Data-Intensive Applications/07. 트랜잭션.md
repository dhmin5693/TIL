# 트랜잭션

> 어떤 저자들은 2단계 커밋에서 유발되는 성능이나 가용성 문제 때문에 생기는 비용이 너무 커서 이를 지원할 수 없다고 주장했다. 우리는 항상 트랜잭션 없이 코딩하는 것보다 트랜잭션을 과용해서 병목지점이 생기는 성능 문제를 애플리케이션 프로그래머가 처리하게 하는게 낫다고 생각한다.

## 개요

### 데이터 시스템이 유발할 수 있는 문제들

- DB 노드의 HW/SW는 언제든지 중지될 수 있으며 실패할 수 있다.
- 애플리케이션 또한 마찬가지로 언제든지 죽을 수 있다.
- 네트워크가 갑자기 중단되면 DB 연결이 갑자기 끊기거나 DB 노드 사이 통신이 안될 수 있다.
- 여러 클라이언트가 동시에 DB write를 수행하여 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다.
- 클라이언트가 부분적으로만 갱신되어서 비정상적인 데이터를 읽을 수 있다.
- 클라이언트 사이의 경쟁 조건은 예측하지 못한 버그를 유발할 수 있다.

### 트랜잭션의 정의

- 여러 개의 읽기/쓰기 작업을 하나의 논리적 단위로 묶은 것
- 전체가 성공하거나, 모두 실패하거나
    - 안정성 보장
- read committed, snapshot isolation, serializability 격리 수준 지원

## 트랜잭션의 애매모호함

### ACID

- DB마다 ACID 구현이 제각각
- ACID를 따르지 않는 시스템은 BASE를 지원한다고들 한다.
    - **B**asically **A**vailable
    - **S**oft state
    - **E**ventual Consistency

### 원자성

- 연산은 실행 전/후의 상태만 있을 뿐, 중간 상태엔 머무를 수 없다.
- 원자성은 동시성과 관련이 없다.
- 원자성은 여러 프로세스가 동시에 같은 데이터에 접근하려 할 때 무슨 일이 생기는지 설명하지 않는다.
- 원자성의 결정적인 특징은 오류 발생 시 모든 연산을 rollback하는 것이다.

### 일관성

- 복제 일관성과 비동기식 복제되는 시스템에서 발생하는 최종적 일관성 (5장)
- 일관성 해싱은 재균형화를 위해 사용하는 파티셔닝 기법
- 일관성은 선형성을 의미
- 일관성은 데이터베이스가 "좋은 상태"에 있어야 한다는 것의 애플리케이션에 특화된 개념
    - 원자성, 격리성, 지속성은 데이터베이스의 속성
    - 일관성은 데이터베이스 뿐만 아니라 애플리케이션에서도 지켜주어야 한다.
    - 따라서 C는 ACID에 실제로 속하는 것이 아니다.

### 격리성

- 클라이언트가 DB의 같은 레코드에 접근하면 동시성 문제가 발생
- 동시에 실행되는 트랜잭션은 서로 격리된 상태
- 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션이 커밋됐을 떄의 결과는 트랜잭션이 순차적으로 실행됐을 떄와 동일함을 보장
- serializable isolation은 성능 손해가 막심하여 실제로는 거의 사용되지 않음.

### 지속성

- 기본적으로 HDD나 SSD 등 비휘발성 저장소에 기록
- 저장소에 저장된 데이터의 오염을 방지하여 `write-ahead log` 와 같은 수단 동반
- 복제 기능을 갖춘 DB는 모든 노드에 복사가 완료되어야 지속성을 만족
- 지속성을 보장하려면 DB는 트랜잭션 성공 전에 복제가 완료될 때까지 기다려야 한다.

### 단일 객체 연산과 다중 객체 연산

- ACID에서 원자성과 격리성은 클라이언트가 한 트랜잭션 내에서 여러 번의 쓰기를 하면 어떻게 될까?
    - 원자성은 all or nothing을 보장하여 부분 실패를 걱정하지 않게끔 한다.
    - 격리성은 트랜잭션이 서로를 방해하지 않도록 보장한다.

### 단일 객체 쓰기

- 원자성과 격리성은 단일 객체를 변경하는 경우에도 적용된다.
- 원자성은 장애 복구(crash recovery)용 로그를 사용하여 구현 가능
- 격리성은 객체 잠금(lock)을 활용하여 구현 가능

### 다중 객체 트랜잭션의 필요성

- 많은 분산형 데이터베이스에서 지원하지 않음

### 오류와 어보트 처리

- 오류 발생 시 어보트 및 안전한 재시도는 트랜잭션의 핵심 기능
    - ACID의 철학이기도 하다.
- 리더 없는 복제 기법을 사용하는 DB는 "best effort"를 기반으로 훨씬 더 많은 일을 하는 대신 이 철학을 따르진 않는다.
    - 오류 복구는 애플리케이션에게 맡긴다.
    - Rails, Django와 같은 특정 프레임워크는 어보트된 트랜잭션을 재시도하지 않으므로 주의가 필요하다.
- 어보트된 트랜잭션 재시도는 효과적이지만 완벽하지 않을 수 있다.
    - 트랜잭션은 성공했으나 네트워크 오류로 서버가 클라이언트에게 커밋 성공을 알리지 못하여 재시도
    - 오류의 원인이 과도한 트래픽이라면 트랜잭션 재시도는 문제를 더욱 악화시키는 행위
    - 회복 가능한 일시적인 오류가 아니라 영구적 오류인 경우 재시도하여도 같은 현상을 반복
    - 트랜잭션이 DB 외부에도 부수 효과가 있다면 트랜잭션이 어보트될 때에도 부수 효과가 실행됨
    - 클라이언트 프로세스가 재시도 중에 죽으면 클라이언트에서 DB에 쓰려고 했던 데이터가 모두 손실

### 완화된 격리 수준

- 두 트랜잭션이 동일한 데이터에 접근하지 않는다면 안전하게 병렬 처리가 가능하다.
- 동시성 문제는 서로 다른 트랜잭션에서 동시에 같은 데이터를 변경하거나 읽으려고 하는 경우에 발생한다.
    - 타이밍에 의해 발생되어 테스트로 발견하기도 어렵고 재현하기도 어렵다.
- **트랜잭션 격리**를 통해 동시성 문제를 완화할 수 있지만 성능 문제가 있을 수 있다.

### 커밋 후 읽기 (Read Committed)

- 가장 기본적인 **트랜잭션 격리 수준**
- 커밋된 데이터만 읽을 수 있음.
- 커밋된 데이터만 덮어 쓸 수 있음.
- dirty read 방지
    - commit되지 않은 데이터를 읽는 현상
    - dirty read가 발생하면 다른 트랜잭션에서 갱신된 값과 갱신되지 않은 값을 혼용하여 읽을 수도 있다.
- dirty write 방지
    - 두 트랜잭션이 동일한 객체를 동시에 갱신하려고 할 때, 먼저 쓴 내용이 아직 커밋되지 않은 트랜잭션에서 쓴 것이고 나중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어써버리는 현상
- 로우 잠금 수준을 사용하여 dirty write를 방지
    - 특정 row를 변경하려면 해당 row에 대한 lock을 획득해야 한다.
    - 트랜잭션이 끝날 때까지 lock을 보유한다.
    - 특정 row에 대한 lock은 한 트랜잭션만 가질 수 있다.
- dirty read는 동일한 lock을 사용하여 읽기를 원하는 트랜잭션이 lock을 잠깐 획득하고 종료와 동시에 해제한다.
    - read lock은 한 row를 오래 잠궈두면 속도 문제가 발생할 수 있어 잘 사용되지 않는다.

### snapshot 격리와 반복 읽기 (Repeatable Read)

- 일시적인 데이터 불일치 현상 방지
- 스냅샷 격리를 통해 커밋된 상태였던 데이터를 본다.
- 읽기만 실행하는 질의에 요긴하다.
- 스냅샷 격리는 읽는 쪽에서 쓰는 쪽을 차단하지 않고 쓰는 쪽에서 읽는 쪽을 차단하지 않는다.
    - lock 경쟁 없이 처리할 수 있어 오래 실행되는 읽기 작업도 처리할 수 있다.
- 여러 트랜잭션이 서로 다른 시점의 DB 상태를 보는 경우, DB는 여러 버전을 함께 유지하고 있어야 한다.
    - 이 기법은 다중 버전 동시성 제어(multi-version concurrency control, MVCC)라 한다.

### 갱신 손실 방지

- 두 트랜잭션이 동시에 쓰기를 실행한 경우 쓰기 충돌(write-write conflict)이 일어날 수 있다.
    - lost update같은 문제도 있다. 특정 트랜잭션의 작업이 무시된다.
- 원자적 쓰기 연산을 통한 방지
    - 데이터의 일부만 갱신
    - 해당 객체에 exclusive lock을 획득하여 구현
- compare-and-set 연산으로 갱신 손실 회피 가능

### 충돌 해소와 복제

- 복제를 적용한 DB에서 갱신 손실을 방지하는 것은 어려운 문제
- 여러 노드에 데이터가 동시에 존재하기 때문에 lock, compare-and-set 기법을 적용할 수 없다.
- 여러 개의 충돌되는 버전을 생성한 후 사후에 애플리케이션 혹은 특별한 데이터 구조를 사용하여 충돌 해소 및 버전 병합
- last write wins(LWW) 는 충돌을 해소하기 가장 쉬운 방법이지만 갱신 손실이 발생하기 쉽다.

### 쓰기 쓰큐(write skew)와 팬텀

- 두 개 이상의 쓰기 연산이 동시에 일어나며 일어나선 안되는 쓰기 연산 오류가 발생하는 현상
    - 긴급 호출을 대기하는 의사는 반드시 하루에 **2명 이상**
    - 3명의 의사가 대기 중인 상태에서 2명이 동시에 대기 중지 버튼 클릭
    - 어플리케이션에선 `if currentlyOnCall >= 2` 조건을 검사하지만, 동시에 클릭했기 때문에 둘다 이 조건을 통과하고 대기 중지 상태로 변경
    - 스냅샷 격리 수준으로는 막기 어려운 문제
- `SELECT FOR UPDATE` 로 일부 쓰기 쓰큐 회피 가능
- 특정 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과를 `팬텀` 이라고 한다.
    - 스냅샷 격리는 read only의 경우 팬텀을 회피할 수 있지만, read-write에서는 아니다.

### 충돌 구체화

- 인위적으로 DB에 lock 객체를 추가하여 팬텀의 문제를 해결할 수 있다.
- 회의실 예약의 경우
    - 예약하려는 시간 범위와 회의실에 대한 모든 조합에 대해 row를 미리 생성
    - 실제로 예약하려는 트랜잭션은 테이블에서 원하는 회의실과 시간 범위에 해당하는 row를 잠글 수 있다.
- 이를 충돌 구체화(materializing conflicts) 라고 한다.
    - 충돌 구체화 방법은 구현하기 어려우며 오류가 발생하기 쉽다.
    - 다른 대안이 불가능한 경우에만 최후의 수단으로 사용해야 한다.

## 직렬성(Serializable)

- 가장 강력한 격리 수준
- 병렬로 실행되는 모든 트랜잭션은 동시성 없이 일렬로 실행되는 것과 같도록 보장
- DB는 모든 경쟁 조건을 막을 수 있다.
- 속도 문제가 심각하다.

### 2단계 잠금 (2 phase locking, 2PL)

- 30년 넘게 직렬성을 구한하는데에 사용된 알고리즘
- 트랜잭션 A가 객체 하나를 읽고 트랜잭션 B가 그 객체에 쓰기를 원한다면 B는 진행하기 전에 A가 커밋되거나 어보트 될때까지 기다려야 한다.
- 트랜잭션 A가 객체에 썼고 트랜잭션 B가 그 객체를 읽기 원한다면 B는 진행하기 전에 A가 커밋되거나 어보트 될때까지 기다려야 한다.
- 스냅샷 격리와는 개념적으로 큰 차이가 있다.
    - 스냅샷 격리의 원칙은 `읽는 쪽은 결코 쓰는 쪽을 막지 않으며 쓰는 쪽도 결코 읽는 쪽을 막지 않는다`
    - 2PL은 직렬성을 제공하지만 다른 쓰기 트랜잭션 뿐만 아니라 읽기 트랜잭션도 진행하지 못하게 막고 그 역도 성립한다.
    - 대신 갱신 손실 및 쓰기 스큐를 포함한 모든 경쟁 조건으로부터 보호된다.

### 2PL 구현

- lock은 shared mode, exclusive mode로 사용
- 트랜잭션이 객체를 읽으려면 shared mode로 lock을 획득해야 한다.
    - shared lock은 여러 객체가 동시에 lock을 획득할 수 있다.
    - 그 객체에 exclusive mode로 lock을 획득한 트랜잭션이 있으면 그 트랜잭션 종료를 기다려야 한다.
- exclusive mode lock을 획득한 트랜잭션만 쓰기가 가능하다.
    - 읽다가 쓰기로 전환한 경우 역시 exclusive lock이 필요하다.
- 트랜잭션이 lock을 가져가면 트랜잭션 종료까지 계속 lock을 갖고 있어야 한다.
    - 2PL에서 첫 번째 단계는 lock 획득, 2번째 단계는 트랜잭션 종료로 모든 lock이 해제되는 것을 말한다.
- lock이 많이 사용되기 때문에 `교착상태` 가 발생할 수 있다.
    - 트랜잭션 A가 트랜잭션 B의 lock 해제를 기다리고 있다.
    - 트랜잭션 B도 트랜잭션 A의 lock 해제를 기다리고 있다.
    - 서로가 서로를 기다리며 아무런 일도 발생하지 않는다.

### 2PL의 성능

- 성능 문제가 가장 큰 약점이다.
    - lock을 획득하고 해제하는 오버헤드
    - 2PL을 사용하면 동시성 수준 저하

### 서술 잠금 (predicate lock)

- shared, exclusive lock과 유사하게 동작
- 특정 객체에 속하지 않고 검색 조건에 부합하는 모든 객체에 속한다.

    ```sql
    SELECT *
     FROM  bookings
    WHERE  room_id = 123
      AND  end_time > '2021-08-25 12:00' AND start_time < '2021-08-25 13:00'
    ```

- 트랜잭션 A가 위 SELECT처럼 어떤 조건에 부합하는 객체를 읽기 원한다면, 질의 조건에 대한 공유 모드 서술 잠금을 획득해야 한다. 다른 트랜잭션 B가 그 조건에 부합하는 어떤 객체에 exclusive lock을 갖고 있으면 A는 질의를 실행하도록 허용되기 전에 B가 lock 해제하기를 기다려야 한다.
- 트랜잭션 A가 어떤 객체를 삽입, 갱신, 삭제하길 원한다면 먼저 기존 값이나 새로운 값 중에 기존의 서술 잠금에 부합하는게 있는지 확인해야 한다. 부합하는 서술 잠금을 트랜잭션 B가 잡고 있다면 A는 진행하기 전에 B가 커밋되거나 어보트될 때까지 기다려야 한다.
- 미래에 추가될 수 있는 객체(팬텀)에도 적용될 수 있다.

### 색인 범위 잠금 (index-range lock)

- 서술 잠금은 잘 동작하지 않는다.
    - 진행 중인 트랜잭션이 lock을 많이 가져간 상태이면 조건에 부합하는 lock 확인에 시간이 오래 걸린다.
    - 이런 이유로 실제로는 index-range locking, next-key locking 을 사용하는 편이다.
- 특정 범위를 전부 잠그는 방법이다.
    - 팬텀과 쓰기 스큐로부터 보호해주는 효과가 생긴다.
    - predicate lock보다는 정밀하지 않지만 오버헤드가 낮아서 좋은 타협안이 된다.

### 직렬성 스냅샷 격리 (Serializable Snapshot Isolation, SSI)

- 완전한 직렬성을 제공하지만 스냅샷 격리 대비 약간의 성능 손해
- 트랜잭션이 다른 트랜잭션들이 잡고 있는 lock을 기다리느라 차단될 필요가 없다.
- 쓰는 쪽은 읽는 쪽을 막지 않고 그 역 또한 막지 않는다. (스냅샷 격리와 동일)
- 어보트가 많으면 SSI 성능에 큰 영향을 미치지만 2PL이나 순차 실행보다는 느린 트랜잭션에 덜 민감하다.

### 비관적 동시성 제어 vs 낙관적 동시성 제어

- 2PL은 비관적 동시성 제어 매커니즘
    - 상호 배제의 원리와 비슷
- SSI는 낙관적 동시성 제어 기법
    - 위험한 상황 발생 가능성이 있을 때 트랜잭션을 막는 대신 괜찮을거라는 희망을 가지고 계속 진행
    - 트랜잭션이 커밋하려 할 때 DB에 나쁜 상황이 발생하지 않았는지 확인 후 커밋
    - 나쁜 상황이 발생했으면 어보트 후 재시도되어야 한다.
    - 경쟁이 심하면 어보트 대상 트랜잭션이 많아져 성능이 떨어진다.

### 오래된 MVCC 읽기 감지

- 반드시 2명 이상 대기해야 하는 의사의 예시를 다시 떠올려본다.
    - 의사는 3명이 대기하고 있다.
    - 트랜잭션 1에서 의사 A가 대기 중단 버튼을 눌렀다.
    - 트랜잭션 2는 트랜잭션 1이 시작한 이후에 시작되었으며, 의사 B가 대기 중단 버튼을 눌렀다.
    - 트랜잭션 1이 끝났다면 2는 시작하지 못했겠지만 그렇지 않아서 트랜잭션 2가 시작되었다.
    - 트랜잭션 2는 오래된 버전의 MVCC를 읽었기 때문이다.
    - 이런 이상 현상을 막으려면 트랜잭션 2가 커밋되기 전 다른 트랜잭션이 커밋되면 어보트되어야 한다.

## 정리

### dirty read

다른 클라이언트가 썼지만 아직 커밋되지 않은 데이터를 읽는 현상.

Read Committed 이상의 격리 수준에서 방지 가능

### dirty write

다른 클라이언트가 썼지만 아직 커밋되지 않은 데이터를 덮어쓰는 현상.

대부분의 트랜잭션 구현은 dirty write를 방지

### 읽기 스큐(read skew, 비반복 읽기)

다른 시점에 DB의 다른 부분을 보는 현상.

스냅샷 격리를 통해 한 트랜잭션 내에서는 같은 부분을 보도록 강제할 수 있으며, 스냅샷 격리는 다중 버전 동시성 제어(MVCC)로 구현한다.

### 갱신 손실 (Lost Update)

두 트랜잭션이 동시에 read-modify-write 연산을 실행

한 트랜잭션이 다른 트랜잭션의 변경을 포함하지 않은 채로 다른 트랜잭션이 쓴 내용을 덮어 데이터가 손실되는 현상

스냅샷 격리로 어느 정도 해결 가능하나, 그렇지 않은 것은 수동 잠금(SELECT FOR UPDATE)가 필요

### 쓰기 스큐

트랜잭션이 무언가를 읽고 읽은 값을 기반으로 어떤 결정을 하고 그 결정을 DB에 쓴다.

그러나 쓰기를 실행하는 시점에는 결정의 전제가 더 이상 참이 아닐 수 있다.

이 문제는 Serializable 격리 수준으로만 해결할 수 있다.

### 팬텀 읽기 (Pantom Read)

트랜잭션이 어떤 검색 조건에 부합하는 객체를 읽는다.

다른 트랜잭션이 그 검색 결과에 영향을 주는 쓰기를 실행한다.

스냅샷 격리는 Pantom read를 약간 막아줄 수 있으나 쓰기 스큐에서 발생하는 팬텀은 index-range lock같은 처리 필요

### 순차 실행

트랜잭션 처리량이 낮은 경우 병렬성을 포기하고 순차적으로 실행

동시성으로 인한 어떠한 문제도 발생하지 않는다.

### 2PL

직렬성을 구현하는 표준적인 방법이나 성능상 하자가 있다.

### 직렬성 스냅샷 격리 (SSI)

낙관적인 방법을 사용하여 트랜잭션이 차단되지 않고 진행할 수 있게 하는 새로운 알고리즘

트랜잭션이 커밋을 원할 때 트랜잭션을 확인하여 실행이 직렬적이지 않다면 어보트
