# 트랜잭션

> 어떤 저자들은 2단계 커밋에서 유발되는 성능이나 가용성 문제 때문에 생기는 비용이 너무 커서 이를 지원할 수 없다고 주장했다. 우리는 항상 트랜잭션 없이 코딩하는 것보다 트랜잭션을 과용해서 병목지점이 생기는 성능 문제를 애플리케이션 프로그래머가 처리하게 하는게 낫다고 생각한다.

## 개요

### 데이터 시스템이 유발할 수 있는 문제들

- DB 노드의 HW/SW는 언제든지 중지될 수 있으며 실패할 수 있다.
- 애플리케이션 또한 마찬가지로 언제든지 죽을 수 있다.
- 네트워크가 갑자기 중단되면 DB 연결이 갑자기 끊기거나 DB 노드 사이 통신이 안될 수 있다.
- 여러 클라이언트가 동시에 DB write를 수행하여 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다.
- 클라이언트가 부분적으로만 갱신되어서 비정상적인 데이터를 읽을 수 있다.
- 클라이언트 사이의 경쟁 조건은 예측하지 못한 버그를 유발할 수 있다.

### 트랜잭션의 정의

- 여러 개의 읽기/쓰기 작업을 하나의 논리적 단위로 묶은 것
- 전체가 성공하거나, 모두 실패하거나
    - 안정성 보장
- read committed, snapshot isolation, serializability 격리 수준 지원

## 트랜잭션의 애매모호함

### ACID

- DB마다 ACID 구현이 제각각
- ACID를 따르지 않는 시스템은 BASE를 지원한다고들 한다.
    - **B**asically **A**vailable
    - **S**oft state
    - **E**ventual Consistency

### 원자성

- 연산은 실행 전/후의 상태만 있을 뿐, 중간 상태엔 머무를 수 없다.
- 원자성은 동시성과 관련이 없다.
- 원자성은 여러 프로세스가 동시에 같은 데이터에 접근하려 할 때 무슨 일이 생기는지 설명하지 않는다.
- 원자성의 결정적인 특징은 오류 발생 시 모든 연산을 rollback하는 것이다.

### 일관성

- 복제 일관성과 비동기식 복제되는 시스템에서 발생하는 최종적 일관성 (5장)
- 일관성 해싱은 재균형화를 위해 사용하는 파티셔닝 기법
- 일관성은 선형성을 의미
- 일관성은 데이터베이스가 "좋은 상태"에 있어야 한다는 것의 애플리케이션에 특화된 개념
    - 원자성, 격리성, 지속성은 데이터베이스의 속성
    - 일관성은 데이터베이스 뿐만 아니라 애플리케이션에서도 지켜주어야 한다.
    - 따라서 C는 ACID에 실제로 속하는 것이 아니다.

### 격리성

- 클라이언트가 DB의 같은 레코드에 접근하면 동시성 문제가 발생
- 동시에 실행되는 트랜잭션은 서로 격리된 상태
- 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션이 커밋됐을 떄의 결과는 트랜잭션이 순차적으로 실행됐을 떄와 동일함을 보장
- serializable isolation은 성능 손해가 막심하여 실제로는 거의 사용되지 않음.

### 지속성

- 기본적으로 HDD나 SSD 등 비휘발성 저장소에 기록
- 저장소에 저장된 데이터의 오염을 방지하여 `write-ahead log` 와 같은 수단 동반
- 복제 기능을 갖춘 DB는 모든 노드에 복사가 완료되어야 지속성을 만족
- 지속성을 보장하려면 DB는 트랜잭션 성공 전에 복제가 완료될 때까지 기다려야 한다.
