# 배열보다는 리스트를 사용하라.

## 배열과 제네릭 타입의 차이

### 공변과 비공변

- 배열은 공변이다.
    - 공변은 함께 변한다는 뜻이다.
    - Sub가 Super의 하위 타입이면 Sub[]는 Super[]의 하위 타입이 된다.
    
    ```java
    Object[] arr = new Long[1];
    arr[0] = "문자열"; // 런타임에서 오류 발생, ArrayStoreException 발생
    ```
    
- 제네릭은 불공변이다.
    - List<T1>과 List<T2> 는 서로 상, 하위의 관계가 아니다.
    
    ```java
    List<Object> ol = new ArrayList<Long>(); // 호환되지 않는 타입이라 컴파일되지 않는다.
    ol.add("문자열은 넣을 수 없음");
    ```
    

- 어느 쪽이든 타입이 달라 넣을수는 없지만, 오류 발생 시점이 런타임/컴파일으로 각각 다르다.

### 실체화 여부

- 배열은 실체화(rify)된다.
    - 배열은 런타임에도 담아야 하는 원소의 타입을 인지하고 확인한다.
    - 위에서 arr[0]에 문자열음 담으려 할 때 exception이 발생한다.
- 제네릭은 런타임 시 소거(erasure) 된다.
    - 컴파일 시점에만 타입을 검사한다.

## 제네릭 배열을 만들지 못하게 한 이유

- 타입 안전성이 떨어진다.
    - 이를 허용하면 컴파일러가 자동 생성한 형변환 코드에서 `ClassCaseException` 이 발생할 수 있다.
