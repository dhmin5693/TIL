# Object 1장[객체, 설계] 정리

## 프로그래밍의 목적

```
모든 소프트웨어 모듈에는 세 가지 목적이 있다.

첫 번째 목적은 실행 중에 제대로 동작하는 것이다.
이 것은 모듈의 존재 이유라고 할 수 있다.

두 번째 목적은 변경을 위해 존재하는 것이다.
대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 한다.
변경하기 어려운 모듈은 제대로 동작하더라도 개선해야 한다.

모듈의 세 번째 목적은 코드를 읽는 사람과 의사소통하는 것이다.
모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다.
읽는 사람과 의사소통할 수 없는 모듈은 개선해야 한다.

- Robert C. Martin
```

**완성**했다고 생각하는 코드는 대부분 첫 번째 목적을 만족한다.

그러나 첫 번째 목적을 만족하는 코드가 반드시 두 번째, 세 번째 목적을 만족하지는 않는다.

## 변경이 어려운 코드

소스코드의 `의존성`이 강하게 엮여있을 수록 수정하기 어렵다.

### 예시

A 클래스가 B, C, D, E, ..., Z 클래스를 의존한다고 가정해보자.

A 클래스에는 B, C, D, E, ..., Z의 메소드를 직접 활용하여 작성되어 있는 상태이다.

### A를 수정한다면?

1. 개발자는 B, C, D, E, ..., Z의 내용을 대부분 숙지하고 있거나
2. 그렇지 않다면 최소 A 내부에서 다른 클래스의 메소드를 어떻게, 왜 활용하는지 확실하게 파악해야 한다.

그렇지 않으면 A는 제대로 변경되었는지 장담할 수 없다.

### 그 외를 수정한다면?

B, C, D, E, ..., Z 중 하나라도 수정한다면, A의 로직에 영향이 가게 된다.

`아주 작은 변화`라도 개발자의 의도와는 맞지 않는 사이드 이펙트가 발생할 수 있다.

### 이런 코드의 특징은

의존성이 과하게 높은 코드는 OOP의 특성을 가졌다고 말하기는 어렵다.

오히려 전통적인 절차지향형 프로그래밍 언어와 같이 작성되어 있을 확률이 크다.

### 결론

`의존성이 강한 코드(결합도가 높은 코드)는 수정하기 어렵고 변경에 취약하다.`

## 재설계

재설계의 목표는 결합성을 낮추는 것이다.

### 자율성을 높이자

위의 가정처럼 A가 B, C를 참조하고 있는 상태라고 하자.

```java
public class A {

    private final B b;
    private final C c;

		void foo() {
        b.getSomething().setCode(c.getCode);
    }
}
```

b의 getSomething 내용이 바뀐다면 `foo()` 는 어떻게 동작할지 장담하기 어렵다.

코드를 다시 보니 `A`는 `C` 에 의존하지 않아도 될 것 같다.

`C` 를 `B` 내부로 옮기면 `A`와 `C`의 의존성을 끊어낼 수 있다.

```java
public class A {

    private final B b;

		void foo(C c) {
        b.somethingCode(c);
    }
}
```

A는 C의 의존성을 끊어냈을 뿐만 아니라 `b.getSomething().setCode(c)` 를 A가 알지 못하도록 숨겼다.

외부에서 코드의 내용을 알 수 없도록 `캡슐화` 를 하고 접근을 제한하면 결합도를 낮출 수 있다.

### 캡슐화와 응집도

`가진 것을 꺼내어 확인하고 명령` 하기보다 `무엇을 하라`는 식으로 메시지를 보내는 코드를 작성해보자.

연관성 없는 작업은 다른 객체에게 위임하는 객체를 `응집도가 높다`고 말한다.

캡슐화가 잘 된 코드는 응집도 또한 높일 수 있다.

### 프로세스와 데이터

`프로세스`는 객체 또는 메소드에서 하고자 하는 `행위`를 의미한다.

데이터를 꺼내다가 하나씩 구현하는 행위는 `절차지향적 프로그래밍` 에 가깝다.

`프로세스`와 `데이터`의 책임을 적절하게 나누고 옮기면 더욱 `객체지향적인 코드`를 작성할 수 있다.

## 객체지향적 설계

맨 처음 언급했던 로버트 마틴의 **목적**을 다시 한번 상기시켜보자.

소프트웨어는 언제든지 변경될 수 있다.

그리고 소프트웨어는 누구든지 변경할 수 있다.

### 설계가 왜 필요한가?

언제든지 변경할 수 있고 누구든지 변경할 수 있는 코드를 작성해야 한다.

보통 릴리즈된 SW는 QA 과정을 거치며 검증한 상태일 것이다.

코드를 수정하면 새로운 버그가 생기지 않았으리라는 보장은 없다.

변경을 수용하기 어려운 코드는 버그가 발생될 확률이 더 높다.

### 따라서...

변경에 유연하게 대응할 수 있는 코드가 필요하다.

객체지향은 의존성을 효율적으로 통제할 수 있는 프로그래밍 패러다임 중 하나이다.

객체지향적 설계는  코드를 더 이해하기 쉽게, 변경하기 쉽게 만들어준다.