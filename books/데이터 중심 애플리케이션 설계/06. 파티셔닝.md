# 파티셔닝

- 데이터셋이 너무 큰 경우 복제하기 어려울 수 있는데, 이런 경우 데이터를 **파티션** 으로 쪼갠다. 이를 **샤딩** 이라고 한다.
- 데이터 파티셔닝을 하는 주 이유는 확장성이다.

## 파티셔닝과 복제

- 보통 복제와 파티셔닝은 함께 적용
- 한 노드에 여러 파티션을 저장할 수도 있음.
- 각 노드는 어떤 파티션에겐 리더이면서 어떤 파티션에겐 팔로워가 되는 구조

### 키-값 데이터 파티셔닝

- 파티셔닝의 목적은 **데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것**
- 파티셔닝이 고르게 이루어지지 않아 데이터가 많거나 질의를 많이 받아 쏠릴 수 있다(skewed).
    - 극단적인 경우 10개 노드 중 9개는 유휴상태, 1개만 계속 일을 할 수 있다.
    - 불균형하게 부하가 높은 파티션을 **핫스팟** 이라고 한다.
- 키-값 데이터 모델에서는 항상 **기본키** 를 통해 레코드에 접근하면 언제나 찾고자 하는 항목을 빨리 찾을 수 있다.

### 키 범위 기준 파티셔닝

- 각 파티션에 연속된 범위의 키를 할당
- 파티션의 경계는 관리자가 수동으로 선택하거나 DB가 자동으로 선택하도록 할 수 있다.
- 각 파티션 내에서는 키를 정렬된 순서로 저장할 수 있다.
- 특정한 접근 패턴이 핫스팟을 유발할 수 있는 단점이 있다.
    - 예를 들어 날짜 단위로 나누면 오늘 기준 한 파티션만 트래픽 과중

### 키의 해시값 기준 파티셔닝

- 쏠림과 핫스팟의 위험으로 인해 `해시 함수`를 사용하여 키의 파티션을 정하는 경우가 많다.
- 해시 함수는 쏠린 데이터를 균일하게 분산시키는데 도움을 준다.
- 단점으로는 범위 질의 시 정렬 순서가 유지되지 않는다는 점이다.
    - 인접한 데이터라 같은 파티션에 저장하는게 효율적일 수 있는 데이터가 서로 다른 파티션에 저장될 수 있다.
    - 예를 들면 시간 단위 질의이다.
- **복합 기본키** 전략은 위의 문제를 해결할 수 있는 방법 중 하나이다.
    - 키의 첫 부분을 해싱하여 파티션을 결정한다.
    - 남은 칼럼을 데이터 정렬용 색인으로 사용한다.

### 쏠린 작업부하와 핫스팟 완화

- 키를 해싱하면 핫스팟을 줄일 수 있지만 극단적인 상황에선 모든 요청이 동일한 파티션에 쏠릴 수 있다.
    - 예를 들면 수백만 팔로워를 거느린 인플루언서가 SNS 상에서 어떠한 동작을 하는 경우이다.
    - 인플루언서의 id는 고정이기 때문에 같은 키를 사용하여 분산되지 않는다.
    - 이런 경우 id 뒤에 2자리의 숫자를 postfix로 붙여주면 100개의 다른 키로 분할시킬 수 있다.
    - 대신 읽기를 실행할 시 100개의 다른 키를 읽어서 조합해야 한다.

### 파티셔닝과 보조 색인

- 보조 색인은 레코드를 **유일하게 식별하는 용도가 아니라 특정 값이 발생한 항목을 검색하는 수단**
- 위의 이유로 파티션에 깔끔하게 대응되지 않는 문제점이 있다.
- 보조 색인 파티셔닝 기법은 주로 문서 기준 보조 색인 파티셔닝, 용어 기반 파티셔닝 사용

### 문서 기준 보조 색인 파티셔닝

- 지역 색인 기법
- 각 파티션에서 보조 색인에 해당하는 색인을 생성
- 동일한 파티션에 관련 데이터가 전부 존재하지 않을 수 있어서 모든 파티션에 질의할 필요가 있음
    - 이렇게 질의를 보내는 방식을 scatter/getter라고 함
    - 몽고DB, 리악, 카산드라, es 등 document NoSQL은 문서 기준 파티셔닝된 보조 색인 사용

### 용어 기준 보조 색인 파티셔닝

- 전역 색인 기법
- 한 노드에만 색인이 저장되면 해당 노드에 병목 발생
    - 전역 색인도 파티셔닝 필요
- 특정 제조사의 빨간색 자동차를 찾으려 하는 경우
    - 빨간 자동차의 정보는 color:red라는 색인 항목에 저장
    - 시작 글자가 a ~ r인 색깔 색인은 파티션 0에, s ~ z는 파티션 1에 저장
    - 제조사 색인도 같은 방법으로 파티셔닝
- 용어에 따라 파티션이 결정되므로 **용어 기준 파티셔닝(term-partitioned)** 이라고 함.
- scatter/getter 없이 효율적으로 읽기 가능
    - 원하는 용어를 포함하는 파티션에 질의하면 되기 때문
- 쓰기가 느리고 복잡하다는 단점이 있음.
- 전역 보조 색인은 보통 비동기로 갱신

## 파티션 재균형화

- 시간이 지나며 데이터베이스에 변화가 생길 수 있다.
    - 질의량이 늘어 부하 처리를 원활히 하기 위해 CPU 추가
    - 데이터를 더 저장하기 위해 디스크와 램 추가
    - 특정 노드에 장애가 발생하여 그 노드가 담당하던 역할을 다른 노드로 이관
- 변화가 생긴 경우 데이터와 요청이 한 노드에서 다른 노드에로 옮겨져야 하는데, 이를 **재균형화** 라고 한다.
- 재균형화 최소 요구사항
    - 재균형화 후, 부하가 클러스터 내에 있는 노드들 사이에 균등하게 분배되어야 한다.
    - 재균형화 도중에도 데이터베이스는 읽기 쓰기가 가능해야 한다.
    - 재균형화가 빨리 실행되고 네트워크와 디스크 I/O 부하를 최소화할 수 있도록 노드들 사이에 데이터가 필요 이상으로 옮겨져서는 안된다.

### 재균형화 전략 1. 해시값에 모드 N 연산 실행

- `쓰면 안 되는 방법`
- mod 10의 경우, 0 ~ 9까지 숫자 배정 가능
    - 10대 고정이라면 데이터를 노드에 할당할 수 있는 가장 쉬운 방법
    - 노드 개수가 바뀌면 대부분의 키를 재조정해주어야 한다.
    - 노드 사이 데이터가 **필요 이상으로 옮겨짐**

### 재균형화 전략 2. 파티션 개수 고정

- 파티션을 노드 대수보다 많이 만들고 각 노드에 여러 파티션 할당
    - 노드 10대로 구성된 클러스터에서 실행되는 DB는 파티션 1000개로 쪼갠다.
    - 각 노드에 100개의 파티션이 할당된다.
- 클러스터에 새 노드를 추가하면 기존 노드에서 파티션 몇 개를 통째로 이관한다.
- 노드의 최대 개수는 초기에 생성한 파티션 개수가 된다.
    - 미래를 대비하고자 한다면 파티션은 충분히 높은 수를 선택하는 편이 좋다.
    - 노드에 할당된 파티션이 너무 많다면 관리포인트로 작용하여 역효과가 생길 수 있다.

### 재균형화 전략 3. 동적 파티셔닝

- 키 범위 파티셔닝을 사용하는 경우 파티션 경계와 개수가 고정되면 매우 불편
    - 파티션 경계를 잘못 지정하면 모든 데이터가 특정 파티션에 몰릴 수 있기 때문
    - HBase나 리싱크DB처럼 키 범위 파티셔닝을 사용하는 db는 파티션을 동적으로 만든다.
- 파티션 크기가 설정값(용량단위)을 넘어서면 파티션을 둘로 쪼개서 원래 파티션의 절반 정도 데이터를 이주시킨다.
- 데이터가 많이 삭제되어 임계값 이하가 된 경우 인접 파티션과 병합한다.
- 파티션은 데이터 용량에 맞춰서 조정된다.
- 대신 파티션 경계에 대한 사전 정보가 없어 시작하는 파티션은 하나가 된다.
    - 사전 분할(pre-splitting)으로 초기 파티션 집합 설정 가능)

### 재균형화 전략 4. 노드 비례 파티셔닝

- 동적 파티셔닝은 파티션 개수가 데이터셋 크기에 비례
- 파티션 개수를 고정하면 개별 파티션 크기가 데이터셋 크기에 비례
- 카산드라 등에서는 파티션 개수가 노드 대수에 비례하게 한다.
    - 노드당 할당되는 파티션 개수 고정
    - 노드 대수가 변함이 없으면 개별 파티션 크기는 데이터셋 크기에 비례하여 증가
    - 노드 대수가 늘어나면 파티션 크기는 작아진다.
    - 개별 파티션 크기를 안정적으로 유지할 수 있다.
- 새 노드가 클러스터에 추가되면 고정 개수의 파티션을 무작위로 선택하여 분할
    - 분할된 파티션의 절반은 그대로 두고 나머지 절반은 새 노드로 이주
    - 새 노드는 기존 노드가 담당하던 부하를 균등하게 배분받게 된다.
