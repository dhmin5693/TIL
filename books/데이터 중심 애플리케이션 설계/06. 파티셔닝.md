# 파티셔닝

- 데이터셋이 너무 큰 경우 복제하기 어려울 수 있는데, 이런 경우 데이터를 **파티션** 으로 쪼갠다. 이를 **샤딩** 이라고 한다.
- 데이터 파티셔닝을 하는 주 이유는 확장성이다.

## 파티셔닝과 복제

- 보통 복제와 파티셔닝은 함께 적용
- 한 노드에 여러 파티션을 저장할 수도 있음.
- 각 노드는 어떤 파티션에겐 리더이면서 어떤 파티션에겐 팔로워가 되는 구조

### 키-값 데이터 파티셔닝

- 파티셔닝의 목적은 **데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것**
- 파티셔닝이 고르게 이루어지지 않아 데이터가 많거나 질의를 많이 받아 쏠릴 수 있다(skewed).
    - 극단적인 경우 10개 노드 중 9개는 유휴상태, 1개만 계속 일을 할 수 있다.
    - 불균형하게 부하가 높은 파티션을 **핫스팟** 이라고 한다.
- 키-값 데이터 모델에서는 항상 **기본키** 를 통해 레코드에 접근하면 언제나 찾고자 하는 항목을 빨리 찾을 수 있다.

### 키 범위 기준 파티셔닝

- 각 파티션에 연속된 범위의 키를 할당
- 파티션의 경계는 관리자가 수동으로 선택하거나 DB가 자동으로 선택하도록 할 수 있다.
- 각 파티션 내에서는 키를 정렬된 순서로 저장할 수 있다.
- 특정한 접근 패턴이 핫스팟을 유발할 수 있는 단점이 있다.
    - 예를 들어 날짜 단위로 나누면 오늘 기준 한 파티션만 트래픽 과중

### 키의 해시값 기준 파티셔닝

- 쏠림과 핫스팟의 위험으로 인해 `해시 함수`를 사용하여 키의 파티션을 정하는 경우가 많다.
- 해시 함수는 쏠린 데이터를 균일하게 분산시키는데 도움을 준다.
- 단점으로는 범위 질의 시 정렬 순서가 유지되지 않는다는 점이다.
    - 인접한 데이터라 같은 파티션에 저장하는게 효율적일 수 있는 데이터가 서로 다른 파티션에 저장될 수 있다.
    - 예를 들면 시간 단위 질의이다.
- **복합 기본키** 전략은 위의 문제를 해결할 수 있는 방법 중 하나이다.
    - 키의 첫 부분을 해싱하여 파티션을 결정한다.
    - 남은 칼럼을 데이터 정렬용 색인으로 사용한다.

### 쏠린 작업부하와 핫스팟 완화

- 키를 해싱하면 핫스팟을 줄일 수 있지만 극단적인 상황에선 모든 요청이 동일한 파티션에 쏠릴 수 있다.
    - 예를 들면 수백만 팔로워를 거느린 인플루언서가 SNS 상에서 어떠한 동작을 하는 경우이다.
    - 인플루언서의 id는 고정이기 때문에 같은 키를 사용하여 분산되지 않는다.
    - 이런 경우 id 뒤에 2자리의 숫자를 postfix로 붙여주면 100개의 다른 키로 분할시킬 수 있다.
    - 대신 읽기를 실행할 시 100개의 다른 키를 읽어서 조합해야 한다.
    # 파티셔닝

- 데이터셋이 너무 큰 경우 복제하기 어려울 수 있는데, 이런 경우 데이터를 **파티션** 으로 쪼갠다. 이를 **샤딩** 이라고 한다.
- 데이터 파티셔닝을 하는 주 이유는 확장성이다.

## 파티셔닝과 복제

- 보통 복제와 파티셔닝은 함께 적용
- 한 노드에 여러 파티션을 저장할 수도 있음.
- 각 노드는 어떤 파티션에겐 리더이면서 어떤 파티션에겐 팔로워가 되는 구조

### 키-값 데이터 파티셔닝

- 파티셔닝의 목적은 **데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것**
- 파티셔닝이 고르게 이루어지지 않아 데이터가 많거나 질의를 많이 받아 쏠릴 수 있다(skewed).
    - 극단적인 경우 10개 노드 중 9개는 유휴상태, 1개만 계속 일을 할 수 있다.
    - 불균형하게 부하가 높은 파티션을 **핫스팟** 이라고 한다.
- 키-값 데이터 모델에서는 항상 **기본키** 를 통해 레코드에 접근하면 언제나 찾고자 하는 항목을 빨리 찾을 수 있다.

### 키 범위 기준 파티셔닝

- 각 파티션에 연속된 범위의 키를 할당
- 파티션의 경계는 관리자가 수동으로 선택하거나 DB가 자동으로 선택하도록 할 수 있다.
- 각 파티션 내에서는 키를 정렬된 순서로 저장할 수 있다.
- 특정한 접근 패턴이 핫스팟을 유발할 수 있는 단점이 있다.
    - 예를 들어 날짜 단위로 나누면 오늘 기준 한 파티션만 트래픽 과중

### 키의 해시값 기준 파티셔닝

- 쏠림과 핫스팟의 위험으로 인해 `해시 함수`를 사용하여 키의 파티션을 정하는 경우가 많다.
- 해시 함수는 쏠린 데이터를 균일하게 분산시키는데 도움을 준다.
- 단점으로는 범위 질의 시 정렬 순서가 유지되지 않는다는 점이다.
    - 인접한 데이터라 같은 파티션에 저장하는게 효율적일 수 있는 데이터가 서로 다른 파티션에 저장될 수 있다.
    - 예를 들면 시간 단위 질의이다.
- **복합 기본키** 전략은 위의 문제를 해결할 수 있는 방법 중 하나이다.
    - 키의 첫 부분을 해싱하여 파티션을 결정한다.
    - 남은 칼럼을 데이터 정렬용 색인으로 사용한다.

### 쏠린 작업부하와 핫스팟 완화

- 키를 해싱하면 핫스팟을 줄일 수 있지만 극단적인 상황에선 모든 요청이 동일한 파티션에 쏠릴 수 있다.
    - 예를 들면 수백만 팔로워를 거느린 인플루언서가 SNS 상에서 어떠한 동작을 하는 경우이다.
    - 인플루언서의 id는 고정이기 때문에 같은 키를 사용하여 분산되지 않는다.
    - 이런 경우 id 뒤에 2자리의 숫자를 postfix로 붙여주면 100개의 다른 키로 분할시킬 수 있다.
    - 대신 읽기를 실행할 시 100개의 다른 키를 읽어서 조합해야 한다.
