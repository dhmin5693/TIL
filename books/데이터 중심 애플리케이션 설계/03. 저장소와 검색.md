# 저장소와 검색

이 장에서는 NoSQL 엔진에 대해 설명한다.

그리고 로그 구조 저장소(log-structured, b-tree같은) 계열 엔진, 페이지 지향(page-oriented) 계열 엔진을 검토한다.

## 데이터베이스를 강력하게 만드는 데이터 구조

굉장히 간단한 데이터베이스를 만드는 실습을 진행한다.

```bash
#!/bin/bash

db_set () {
    echo "$1,$2" >> database
}

db_get () {
    grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}
```

아래는 작동 예시다.

```bash
$ db_set 123456 '{"name":"London","attractions":["Big Ben","London Eye"]}'

$ db_set 42 '{"name":"San Francisco","attractions":["Golden Gate Bridge"]}'

$ db_get 42
{"name":"San Francisco","attractions":["Golden Gate Bridge"]}
```

- db_set은 database 파일의 가장 아랫줄에 한 줄씩 추가한다.
    - 파일 추가 작업은 매우 효율적이다.
    - 중복된 데이터를 삭제하지 못한다는 단점이 있다.
    - 데이터를 한 줄씩 추가하다보면 파일 하나가 너무 커진다는 문제가 발생한다. 특정 크기가 되면 파일을 분리하는 것이 좋은 해결책이다. 이렇게 분할한 파일을 `Segment` 라고 한다.
- db_get은 맨 아래서부터 하나씩 탐색하며 가장 최신 데이터를 가져온다.
    - 가장 위부터 찾는 경우 가장 오래된 데이터를 탐색한다.
    - 데이터베이스에 레코드가 많으면 굉장히 비효율적이다. 시간 복잡도는 O(n)이다.
    - O(n)은 레코드가 많아지면 거기에 비례하여 탐색 시간도 커진다.
    - 원하는 레코드를 빠르게 찾기 위해서는 `index` 데이터 구조가 필요하다.

### 색인 (index)

색인은 탐색을 더 빠르게 하기 위해 부가적인 `metadata` 를 유지하는 것을 의미한다.

단점으로는 쓰기 작업 효율이 떨어진다.

원본 데이터와 `metadata`를 저장해야 하며 기존에 저장된 색인 또한 갱신해야 하기 때문이다.

색인은 저장소 시스템에서 중요한 트레이드 오프이다.

색인을 잘 선택하면 탐색 속도가 매우 빠르겠지만 색인이 너무 많다면 쓰기 속도에 큰 영향을 미친다.

### 해시 색인

- 해시 색인은 key-value 쌍의 `hashMap` 구조로 구현되어 있다.
- 값을 조회하면 해시맵을 사용하여 데이터의 오프셋을 찾고 값을 구해온다.
- 세그먼트가 되어있는 파일에 대해선 compaction을 수행할 수 있다.
    - compaction은 중복 키를 버리고 최신 갱신 값만 유지하는 것을 의미한다.
    - 각 세그먼트는 컴팩션 작업으로 최소한의 크기로 줄어든다.
    - 각 세그먼트는 인메모리 해시 테이블을 갖는다. 컴팩션으로 인해 줄어들기 때문에 조회 시 많은 해시맵을 확인할 필요가 없다.
    - 인메모리 해시 테이블이기 때문에 DB 혹은 서버 재시작 시 해시맵이 손실된다.
- 키가 너무 많은 경우 문제가 될 수 있다.
    - 랜덤 액세스 I/O가 많이 발생한다.
    - 디스크 확장 비용이 비싸다.
    - 해시 키 충돌을 위한 성가신 알고리즘이 필요하다.
- 해시 테이블은 range query에 비효율적이다.
    - key001 ~ key100을 검색하고 싶다면 key001, key002, ... key100 을 순서대로 모두 검색해야 한다.

### Sorted String Table

- 세그먼트 파일 형식을 키로 정렬하면 Sorted String Table(SS table)이다.
- 각 키는 세그먼트 파일 내에서 단 한 번만 나타나야 한다. 컴팩션 작업이 이를 보장한다.
- 이진 트리 알고리즘을 활용하면 정렬 상태를 유지하기가 간편하다
    - Red-Black Tree, AVL Tree, B Tree 등
