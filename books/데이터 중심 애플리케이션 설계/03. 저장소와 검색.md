# 저장소와 검색

이 장에서는 NoSQL 엔진에 대해 설명한다.

그리고 로그 구조 저장소(log-structured, b-tree같은) 계열 엔진, 페이지 지향(page-oriented) 계열 엔진을 검토한다.

## 데이터베이스를 강력하게 만드는 데이터 구조

굉장히 간단한 데이터베이스를 만드는 실습을 진행한다.

```bash
#!/bin/bash

db_set () {
    echo "$1,$2" >> database
}

db_get () {
    grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}
```

아래는 작동 예시다.

```bash
$ db_set 123456 '{"name":"London","attractions":["Big Ben","London Eye"]}'

$ db_set 42 '{"name":"San Francisco","attractions":["Golden Gate Bridge"]}'

$ db_get 42
{"name":"San Francisco","attractions":["Golden Gate Bridge"]}
```

- db_set은 database 파일의 가장 아랫줄에 한 줄씩 추가한다.
    - 파일 추가 작업은 매우 효율적이다.
    - 중복된 데이터를 삭제하지 못한다는 단점이 있다.
    - 데이터를 한 줄씩 추가하다보면 파일 하나가 너무 커진다는 문제가 발생한다. 특정 크기가 되면 파일을 분리하는 것이 좋은 해결책이다. 이렇게 분할한 파일을 `Segment` 라고 한다.
- db_get은 맨 아래서부터 하나씩 탐색하며 가장 최신 데이터를 가져온다.
    - 가장 위부터 찾는 경우 가장 오래된 데이터를 탐색한다.
    - 데이터베이스에 레코드가 많으면 굉장히 비효율적이다. 시간 복잡도는 O(n)이다.
    - O(n)은 레코드가 많아지면 거기에 비례하여 탐색 시간도 커진다.
    - 원하는 레코드를 빠르게 찾기 위해서는 `index` 데이터 구조가 필요하다.

### 색인 (index)

색인은 탐색을 더 빠르게 하기 위해 부가적인 `metadata` 를 유지하는 것을 의미한다.

단점으로는 쓰기 작업 효율이 떨어진다.

원본 데이터와 `metadata`를 저장해야 하며 기존에 저장된 색인 또한 갱신해야 하기 때문이다.

색인은 저장소 시스템에서 중요한 트레이드 오프이다.

색인을 잘 선택하면 탐색 속도가 매우 빠르겠지만 색인이 너무 많다면 쓰기 속도에 큰 영향을 미친다.

### 해시 색인

- 해시 색인은 key-value 쌍의 `hashMap` 구조로 구현되어 있다.
- 값을 조회하면 해시맵을 사용하여 데이터의 오프셋을 찾고 값을 구해온다.
- 세그먼트가 되어있는 파일에 대해선 compaction을 수행할 수 있다.
    - compaction은 중복 키를 버리고 최신 갱신 값만 유지하는 것을 의미한다.
    - 각 세그먼트는 컴팩션 작업으로 최소한의 크기로 줄어든다.
    - 각 세그먼트는 인메모리 해시 테이블을 갖는다. 컴팩션으로 인해 줄어들기 때문에 조회 시 많은 해시맵을 확인할 필요가 없다.
    - 인메모리 해시 테이블이기 때문에 DB 혹은 서버 재시작 시 해시맵이 손실된다.
- 키가 너무 많은 경우 문제가 될 수 있다.
    - 랜덤 액세스 I/O가 많이 발생한다.
    - 디스크 확장 비용이 비싸다.
    - 해시 키 충돌을 위한 성가신 알고리즘이 필요하다.
- 해시 테이블은 range query에 비효율적이다.
    - key001 ~ key100을 검색하고 싶다면 key001, key002, ... key100 을 순서대로 모두 검색해야 한다.

### Sorted String Table

- 세그먼트 파일 형식을 키로 정렬하면 Sorted String Table(SS table)이다.
- 각 키는 세그먼트 파일 내에서 단 한 번만 나타나야 한다. 컴팩션 작업이 이를 보장한다.
- 이진 트리 알고리즘을 활용하면 정렬 상태를 유지하기가 간편하다
    - Red-Black Tree, AVL Tree, B Tree 등

### LSM Tree (Log-Structured Merge-Tree)

- 정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진
- key-value 구조로 표현
- 쓰기 연산이 빠르다.
    - 읽기 연산은 상대적으로 느리다.
    - 컴팩션 단계에 있는 데이터 구조와 SS 테이블을 확인하기 때문
- B Tree 대비 쓰기 처리량을 높게 유지할 수 있다.
    - `write amplification`이 덜 일어나고 순차적으로 컴팩션된 SS 테이블 파일을 쓰기 때문
    - wirte amplification은 한 번의 쓰기 연산에 디스크에 여러 번 쓰는 동작을 의미한다.
- 압축율이 좋아 디스크에 생성되는 파일이 상대적으로 적다.
- write amplification, 압축율 등의 이유로 SSD에서 사용 시 유리하다.

### B Tree

- 가장 널리 사용되는 색인 방법으로 정렬된 key-value 쌍 구조를 이룬다.
- 읽기 연산이 빠르다.
- `4KB` 크기의 고정 크기 블록(페이지)로 나누고 한 번에 하나의 페이지에 Read/Write
- 각 페이지는 주소나 위치를 이용하여 식별
- 탐색은 루트 노드에서 시작하여 리프 노드를 찾을 때까지 하위 페이지를 계속 탐색
- 하위 페이지 참조 횟수를 `분기 계수(branching factor)` 라고 한다.
- 키 값 갱신 시 키를 포함하는 리프 페이지를 검색하고 페이지의 값을 바꾼 뒤 페이지를 디스크에 다시 기록한다.

### 기타 색인 구조

- PK index는 대표적인 key-value index
- 보조 색인
    - create index 명령어로 생성
    - PK index와 달리 key가 고유하지 않을 수 있으나 로우 식별자를 추가하여 고유하게 만들수는 있다.
    - B Tree, LSM Tree 모두 사용 가능

### 다중 칼럼 색인 (Multi column index)

- 다중 컬럼에 동시에 질의를 하는 경우 사용
- 가장 일반적인 유형은 결합 색인 (concatenated index)

### 전문 검색과 퍼지 색인

- 철자가 틀린 단어, 유사한 키와 같이 애매모호한(fuzzy) 질의에는 별도의 색인이 필요하다.
- lucene 엔진은 오타를 대비하는 edit distance 내 단어를 검색할 수 있다.

### In memory Database

- 일반적인 경우엔 재시작하면 모든 데이터 손실
- 재시작 시 메모리에 다시 적재하기 위해 디스크에도 데이터를 저장
- 메모리에 적재하기 때문에 `매우 빠르다는 특성` 을 지닌다.
- redis, memcached 등
