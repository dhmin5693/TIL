# 복제

- 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지하는 것
- 실제로 복사하는 방법과 파티셔닝(샤딩)하여 분산하는 방법

## 리더와 팔로워

- 복사본을 저장하는 노드는 `replica` 라고 부름
- `reader` 는 데이터를 직접적으로 저장하는 역할이며, 데이터 저장 즉시 `replica` 에 데이터를 복제한다.

### 동기식 대 비동기식 복제

1. 데이터 갱신 요청 수신
2. 리더가 요청을 받아서 데이터 변경
3. 데이터 변경 정보를 팔로워(replica) 에게 전달

- 동기식
    - 위의 flow를 실행할 때, 리더가 팔로워의 저장 완료를 기다리면 동기식이다.
    - 동기식은 리더와 팔로워가 일관된 최신 데이터를 가지는 것을 보장한다
    - 동기 작업으로 처리 중 팔로워가 응답하지 않거나 응답이 늦으면 쓰기 작업이 처리되지 않을 수 있다.
    - 그렇기 때문에 하나의 노드에 장애가 생겨도 전체 시스템을 멈추게 할 수 있다.
    - 현실적으로 모든 팔로워를 동기식으로 구현하기보다는 1개 노드를 동기식, 그 외를 비동기식으로 설정하여 사용한다.

### 노드 중단 처리

- 노드는 장애로 중단될 수도 있지만 계획된 유지보수(OS 업데이트 등)로 중단될 수 있다.
- 개별 노드의 장애에도 전체 시스템이 동작해야 하며 노드 중단의 영향을 최소화해야 한다.

### 팔로워 장애: 따라잡기 복구

- 팔로워가 데이터 변경 요청을 받으면 그 변경 로그를 로컬에 저장
- 팔로워가 죽어 재시작하거나 네트워크 오류가 발생하는 경우 로그를 기반으로 복구 가능

### 리더 장애: 장애 복구

- 팔로워 중 하나를 새로운 리더로 승격
- 클라이언트는 새로운 리더로 쓰기를 전송해야 하기 때문에 재설정 필요
- 이 과정을 `장애 복구 (failover)` 라고 함.

### 논리적(로우 기반) 로그 복제

- 논리적 로그
    - 복제와 저장소 엔진을 위해 다른 로그 형식을 사용
- 여러 로우를 수정하는 트랜잭션은 여러 로그 레코드를 생성하고 트랜잭션 커밋을 레코드에 표시

### 트리거 기반 복제

- Oracle Golden Gate(OGG)는 DB 로그를 읽어 애플리케이션이 데이터를 변경할 수 있게 함
- 트리거나 스토어드 프로시저를 활용한 복제 기법

### 복제 지연 문제

- 비동기 팔로워 방식에서 팔로워가 뒤쳐지는 경우 지난 정보를 볼 수 있는 가능성이 있음 (불일치)
- DB에 쓰기를 잠깐 멈추면 팔로워는 리더를 따라잡게 됨 (최종적 일관성)

### 단조 읽기

- 비동기 팔로워는 데이터를 바로 동기화시키지 못하는 특성으로 인해 발생
- 3버전의 로우를 저장했으나 사용자가 쿼리 입력 시 2 → 1 순으로 읽히는, 시간이 거꾸로 흐르는 듯한 현상
- **단조 읽기(monotonic read)**는 이런 종류의 이상 현상이 발생하지 않도록 보장

### 일관된 순서로 읽기

- 비동기 팔로워 방식에서 읽는 순서 문제로 인해 쓰기 순서가 꼬이는 인과성 문제가 발생할 우려가 있음.
- ***일관된 순서로 읽기*** 보장을 사용하면 일련의 쓰기 작업의 순서를 보장할 수 있다.
